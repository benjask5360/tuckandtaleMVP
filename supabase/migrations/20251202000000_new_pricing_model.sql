-- Migration: New Hybrid Pricing Model
-- Replaces old subscription tiers (Moonlight/Starlight/Supernova) with new model:
-- - Free trial: First illustrated story free
-- - Story #2: Generate then paywall
-- - Story #3+: Paywall before generation
-- - Stories Plus: $14.99/month for 30 stories

-- =====================================================
-- PART 1: Add new columns to user_profiles
-- =====================================================

-- Track total stories generated by user (all types)
ALTER TABLE user_profiles ADD COLUMN IF NOT EXISTS
  total_stories_generated INTEGER DEFAULT 0;

-- Track if user has used their free illustrated trial
ALTER TABLE user_profiles ADD COLUMN IF NOT EXISTS
  free_trial_used BOOLEAN DEFAULT FALSE;

-- Generation credits from $4.99 single story purchases
ALTER TABLE user_profiles ADD COLUMN IF NOT EXISTS
  generation_credits INTEGER DEFAULT 0;

-- =====================================================
-- PART 2: Add new columns to content table
-- =====================================================

-- Whether story has been unlocked via payment
ALTER TABLE content ADD COLUMN IF NOT EXISTS
  is_unlocked BOOLEAN DEFAULT FALSE;

-- Whether this story requires paywall (story #2)
ALTER TABLE content ADD COLUMN IF NOT EXISTS
  requires_paywall BOOLEAN DEFAULT FALSE;

-- Reference to the purchase that unlocked this story
ALTER TABLE content ADD COLUMN IF NOT EXISTS
  unlock_purchase_id TEXT;

-- =====================================================
-- PART 3: Create story_purchases table
-- =====================================================

CREATE TABLE IF NOT EXISTS story_purchases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  story_id UUID REFERENCES content(id) ON DELETE SET NULL, -- NULL for generation credits
  purchase_type TEXT NOT NULL CHECK (purchase_type IN ('single_story', 'generation_credit', 'subscription')),
  stripe_payment_intent_id TEXT,
  stripe_session_id TEXT,
  amount_cents INTEGER NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for efficient queries
CREATE INDEX IF NOT EXISTS idx_story_purchases_user ON story_purchases(user_id);
CREATE INDEX IF NOT EXISTS idx_story_purchases_story ON story_purchases(story_id);
CREATE INDEX IF NOT EXISTS idx_story_purchases_created ON story_purchases(created_at);

-- RLS policies for story_purchases
ALTER TABLE story_purchases ENABLE ROW LEVEL SECURITY;

-- Users can view their own purchases
CREATE POLICY "Users can view own purchases"
  ON story_purchases FOR SELECT
  USING (auth.uid() = user_id);

-- Only service role can insert/update purchases (via webhooks)
CREATE POLICY "Service role can manage purchases"
  ON story_purchases FOR ALL
  USING (auth.role() = 'service_role');

-- =====================================================
-- PART 4: Helper function to increment generation credits
-- =====================================================

CREATE OR REPLACE FUNCTION increment_generation_credits(p_user_id UUID)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE user_profiles
  SET generation_credits = generation_credits + 1,
      updated_at = NOW()
  WHERE id = p_user_id;
END;
$$;

-- =====================================================
-- PART 5: Helper function to use a generation credit
-- =====================================================

CREATE OR REPLACE FUNCTION use_generation_credit(p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  current_credits INTEGER;
BEGIN
  SELECT generation_credits INTO current_credits
  FROM user_profiles
  WHERE id = p_user_id;

  IF current_credits > 0 THEN
    UPDATE user_profiles
    SET generation_credits = generation_credits - 1,
        updated_at = NOW()
    WHERE id = p_user_id;
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;
END;
$$;

-- =====================================================
-- PART 6: Helper function to increment total stories
-- =====================================================

CREATE OR REPLACE FUNCTION increment_total_stories(p_user_id UUID)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  new_count INTEGER;
BEGIN
  UPDATE user_profiles
  SET total_stories_generated = total_stories_generated + 1,
      updated_at = NOW()
  WHERE id = p_user_id
  RETURNING total_stories_generated INTO new_count;

  RETURN new_count;
END;
$$;

-- =====================================================
-- PART 7: Backfill total_stories_generated for existing users
-- =====================================================

-- Count existing completed stories for each user
UPDATE user_profiles up
SET total_stories_generated = (
  SELECT COUNT(*)
  FROM content c
  WHERE c.user_id = up.id
    AND c.content_type = 'story'
    AND c.generation_status IN ('complete', 'text_complete')
    AND c.deleted_at IS NULL
);
